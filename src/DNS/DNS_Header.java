package DNS;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.Arrays;


public class DNS_Header extends Decode {



    void encode() {
        for (int i = 0; i < 2; i ++) {
            encoded_output.add(decoded_input.get(i)); // First 2 bytes copy over identifier label
        }

        // Various Codes combined into two bytes
        byte codes_1 = -127;
        byte codes_2 = 32; // todo this is copied from question. change to -96 (google's response) if needed
        encoded_output.add(codes_1); // Codes
        encoded_output.add(codes_2); // Codes

        // Entries in the question section
        byte qd_count_1 = 0;
        byte qd_count_2 = 1;
        encoded_output.add(qd_count_1);
        encoded_output.add(qd_count_2);

        // Records in the answer section
        byte an_count_1 = 0;
        byte an_count_2 = 1;
        encoded_output.add(an_count_1);
        encoded_output.add(an_count_2);

        // Records in the name server section
        byte ns_count_1 = 0;
        byte ns_count_2 = 0;
        encoded_output.add(ns_count_1);
        encoded_output.add(ns_count_2);

        // Records in the additional section
        byte ar_count_1 = 0;
        byte ar_count_2 = 1;
        encoded_output.add(ar_count_1);
        encoded_output.add(ar_count_2);
    }


    // NO SETTERS ONLY GETTERS

//    This class should store all the data provided by the 12 byte DNS header. See the spec for all the fields needed.
//
//    This class should have the following public methods:
//
//    static DNSHeader decodeHeader(InputStream) --read the header from an input stream (we'll use a ByteArrayInputStream but we will only use the basic read methods of input stream to read 1 byte, or to fill in a byte array, so we'll be generic).
//    static DNSHeader buildResponseHeader(DNSMessage request, DNSMessage response) -- This will create the header for the response. It will copy some fields from the request
//    void writeBytes(OutputStream) --encode the header to bytes to be sent back to the client. The OutputStream interface has methods to write a single byte or an array of bytes.
//    String toString() -- Return a human readable string version of a header object. A reasonable implementation can be autogenerated by your IDE.
//            You'll probably need a few getters, but you should NOT provide any setters.
//
//    Since this is the first thing in a DNS request, you should be able to test that you can read/decode the header before starting on other classes.
//


    public void decode(InputStream inputStream) throws IOException {

        System.out.println("inputstream " + inputStream.toString());


//        dns_header.id_part_1 = (byte) inputStream.read();
//        dns_header.id_part_2 = (byte) inputStream.read();
//        dns_header.status_1 = (byte) inputStream.read();
//        dns_header.status_2 = (byte) inputStream.read();
//        dns_header.qd_count_1 = (byte) inputStream.read();
//        dns_header.qd_count_2 = (byte) inputStream.read();

        for (int i = 0; i < 12; i++) {
            DNS_Message.get_next_byte(inputStream, decoded_input);
        }





        int nextByte = 0;
//
//        for(int i = 0; i < 2; i++) {
//            nextByte = inputStream.read();
//            System.out.println(nextByte);
//        }
//        char c=(char)nextByte;
//        System.out.println(c);

    }

//

//
//    void writeBytes(OutputStream outputStream) throws IOException {
//
////        DNS_Header dns_header = new DNS_Header();
//
//        outputStream.write(output, 0, 12);
//    }

    @Override
    public int hashCode() {
        return super.hashCode();
    }

    @Override
    public boolean equals(Object obj) {
        return super.equals(obj);
    }

    @Override
    public String toString() {
        return "DNS_Header{}";
    }
}
