package DNS;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Arrays;


public class DNS_Header {
//    public byte id_part_1;
//    public byte id_part_2;
//    public byte status_1;
//    public byte status_2;
//    public byte qd_count_1;
//    public byte qd_count_2;
    public byte[] input = new byte[12];
    public byte[] output = new byte[12];

    // NO SETTERS ONLY GETTERS

//    This class should store all the data provided by the 12 byte DNS header. See the spec for all the fields needed.
//
//    This class should have the following public methods:
//
//    static DNSHeader decodeHeader(InputStream) --read the header from an input stream (we'll use a ByteArrayInputStream but we will only use the basic read methods of input stream to read 1 byte, or to fill in a byte array, so we'll be generic).
//    static DNSHeader buildResponseHeader(DNSMessage request, DNSMessage response) -- This will create the header for the response. It will copy some fields from the request
//    void writeBytes(OutputStream) --encode the header to bytes to be sent back to the client. The OutputStream interface has methods to write a single byte or an array of bytes.
//    String toString() -- Return a human readable string version of a header object. A reasonable implementation can be autogenerated by your IDE.
//            You'll probably need a few getters, but you should NOT provide any setters.
//
//    Since this is the first thing in a DNS request, you should be able to test that you can read/decode the header before starting on other classes.
//


    static DNS_Header decodeHeader(InputStream inputStream) throws IOException {

        System.out.println("inputstream " + inputStream.toString());

        DNS_Header dns_header = new DNS_Header();

//        dns_header.id_part_1 = (byte) inputStream.read();
//        dns_header.id_part_2 = (byte) inputStream.read();
//        dns_header.status_1 = (byte) inputStream.read();
//        dns_header.status_2 = (byte) inputStream.read();
//        dns_header.qd_count_1 = (byte) inputStream.read();
//        dns_header.qd_count_2 = (byte) inputStream.read();

        for (int i = 0; i < 12; i++) {
            dns_header.input[i] = DNS_Message.get_next_byte(inputStream, DNS_Message.header);
        }

        System.out.println("tests " + dns_header.input[2]);

        int nextByte = 0;
//
//        for(int i = 0; i < 2; i++) {
//            nextByte = inputStream.read();
//            System.out.println(nextByte);
//        }
//        char c=(char)nextByte;
//        System.out.println(c);

        return dns_header;
    }

//
//    static DNS_Header buildResponseHeader(DNS_Message request, DNS_Message response) {
//
//
//
//    }
//
    void writeBytes(OutputStream outputStream) throws IOException {

//        DNS_Header dns_header = new DNS_Header();

        outputStream.write(output, 0, 12);
    }

    @Override
    public int hashCode() {
        return super.hashCode();
    }

    @Override
    public boolean equals(Object obj) {
        return super.equals(obj);
    }

    @Override
    public String toString() {
        return "DNS_Header{}";
    }
}
